#include "adjust.h"

	.code16
	.text

	.globl	bootsec
stack		= 0x7c00
driveno		= (stack-6)
sectors		= (stack-8)
secpercyl	= (stack-12)

BIOS_kbdflags	= 0x417
BIOS_page	= 0x462

/* Секция данных для загрузочного сектора */
	.section ".bootsec", "a", @nobits
	.globl	bootsec
bootsec:
	.space	512  /* Резервируем 512 байт для загрузочного сектора */

	.text
	.globl	_start
_start:
	.byte	0x33, 0xc0	/* xorw	%ax, %ax - Обнуление регистра %ax */
	cli			/* Отключение прерываний */
	movw	%ax, %ds	/* Установка сегмента данных в 0 */
	movw	%ax, %ss	/* Установка сегмента стека в 0 */
	movw	$stack, %sp	/* Установка указателя стека */
	movw	%sp, %si	/* Установка %si в значение указателя стека */
	pushw	%es		/* Сохранение сегмента данных в стеке */
	pushw	%di		/* Сохранение указателя на PnP заголовок */
	movw	%ax, %es	/* Установка сегмента данных */
	sti			/* Включение прерываний */
	cld			/* Сброс флага направления */

/* Копирование загрузочного сектора в 0:0x600 */
	movw	$_start, %di	/* Установка указателя источника на начало кода */
	movw	$(512/2), %cx	/* Количество слов для копирования */
	rep; movsw		/* Копирование данных из источника в целевой сегмент */

/* Переход к следующему этапу */
	ljmpw	$0, $next
next:

	ADJUST_DRIVE
	pushw	%dx		/* Сохранение номера диска */

/* Проверка наличия EBIOS */
	pushw	%dx		/* Номер диска */
	movb	$0x41, %ah	/* Функция для проверки наличия EBIOS */
	movw	$0x55aa, %bx	/* Сигнатура для проверки */
	xorw	%cx, %cx	/* Обнуление регистра %cx */
	xorb	%dh, %dh	/* Обнуление старшего байта %dh */
	stc			/* Установка флага переноса */
	int	$0x13		/* Вызов прерывания BIOS */
	jc	1f		/* Переход на метку 1, если ошибка */
	cmpw	$0xaa55, %bx	/* Сравнение сигнатуры */
	jne	1f		/* Переход на метку 1, если сигнатуры не совпадают */
	shrw	%cx		/* Обработка битов для фиксированных дисков */
	jnc	1f		/* Переход на метку 1, если нет EBIOS */

/* Патчирование кода для работы с EBIOS */
	movl	$0xeb42b4+((read_common-read_sector_cbios-4) << 24), \
		(read_sector_cbios)

1:
	popw	%dx		/* Восстановление номера диска */

/* Получение геометрии диска (C/H/S) */
	movb	$0x08, %ah	/* Функция для получения геометрии диска */
	int	$0x13		/* Вызов прерывания BIOS */
	andw	$0x3f, %cx	/* Количество секторов */
	pushw	%cx		/* Сохранение количества секторов в стеке */
	movzbw	%dh, %ax	/* Получение количества головок */
	incw	%ax		/* Коррекция значения для подсчета */
	mulw	%cx		/* Умножение головок на количество секторов */

/* Сохранение количества секторов на цилиндр в стеке */
	pushw	%dx		/* Высший разряд */
	pushw	%ax		/* Низший разряд */

	xorl	%eax, %eax	/* Обнуление регистра %eax */
	cdq			/* Расширение знака регистра %eax в %edx */
	call	scan_partition_table	/* Вызов функции сканирования таблицы разделов */

/* Если мы здесь, то нет операционной системы */
missing_os:
	call	error
	.ascii	"Missing operating system.\r\n"

/*
 * read_sector: Чтение одного сектора, указанный в %eax, в 0x7c00.
 * CF установлен при ошибке. Все регистры сохранены.
 */
read_sector:
	pushal
	xorl	%edx, %edx	/* Обнуление регистра %edx */
	movw	$bootsec, %bx	/* Установка адреса буфера для сектора */
	pushl	%edx		/* Высший разряд LBA */
	pushl	%eax		/* Низший разряд LBA */
	pushw	%es		/* Сегмент буфера */
	pushw	%bx		/* Смещение буфера */
	pushw	$1		/* Количество секторов */
	pushw	$16		/* Размер пакета */
	movw	%sp, %si	/* Установка указателя стека */

/* Этот фрагмент пропускается, если у нас есть EBIOS */
	read_sector_cbios:
	divl	(secpercyl)	/* Деление для получения цилиндра */
	shlb	$6, %ah	/* Коррекция значения %ah */
	movb	%ah, %cl	/* Установка значения цилиндра */
	movb	%al, %ch	/* Установка значения сектора */
	xchgw	%dx, %ax	/* Обмен значениями регистров */
	divb	(sectors)	/* Деление для получения головки */
	movb	%al, %dh	/* Установка значения головки */
	orb	%ah, %cl	/* Объединение значений */
	incw	%cx		/* Коррекция для 1-based значения */
	movw	$0x0201, %ax	/* Установка функции чтения сектора */

/* Чтение сектора с использованием общего кода */
read_common:
	movb	(driveno), %dl	/* Установка номера диска */
	int	$0x13		/* Вызов прерывания BIOS для чтения сектора */
	leaw	16(%si), %sp	/* Восстановление указателя стека */
	popal
	ret

/*
 * read_partition_table:
 * Чтение таблицы разделов (по адресу в %eax) и копирование
 * таблицы разделов в буфер ptab.
 *
 * Искажает %si, %di и %cx, остальные регистры сохранены.
 * %cx = 0 по завершению.
 *
 * При ошибке CF установлен, ptab перезаписан мусором.
 */
ptab	= _start+446

read_partition_table:
	call	read_sector	/* Чтение сектора таблицы разделов */
	movw	$bootsec+446, %si	/* Источник */
	movw	$ptab, %di		/* Приемник */
	movw	$(16*4/2), %cx	/* Количество слов */
	rep ; movsw		/* Копирование данных */
	ret

/*
 * scan_partition_table:
 * Сканирование таблицы разделов, загруженной в область таблицы разделов.
 * Сохранение всех регистров.
 *
 * При входе:
 * %eax - базовый адрес (местоположение этой таблицы разделов)
 * %edx - корень (смещение от MBR, или 0 для MBR)
 *
 * Эти значения сохраняются в стековых ячейках:
 * 28(%bp) - %eax - база
 * 20(%bp) - %edx - корень
 */

scan_partition_table:
	pushal
	movw	%sp, %bp	/* Сохранение указателя стека */

/* Поиск активных разделов */
	movw	$ptab, %bx	/* Установка указателя на таблицу разделов */
	movw	$4, %cx	/* Количество разделов */
	xorw	%ax, %ax	/* Обнуление счетчика активных разделов */
	push	%bx
	push	%cx
5:
	testb	$0x80, (%bx)	/* Проверка флага активности */
	jz	6f
	incw	%ax		/* Увеличение счетчика активных разделов */
	movw	%bx, %si
6:
	addw	$16, %bx	/* Переход к следующему разделу */
	loopw	5b

	decw	%ax		/* Количество найденных активных разделов */
	jz	boot		/* Если нет активных разделов, перейти к загрузке */
	jns	too_many_active

/* Нет активных разделов, ищем расширенные разделы */
	popw	%cx		/* Восстановление количества разделов */
	popw	%bx		/* Восстановление указателя на таблицу разделов */
7:
	movb	4(%bx), %al	/* Чтение типа раздела */
	cmpb	$0x0f, %al	/* Проверка на расширенный раздел Win9x */
	je	8f
	andb	$~0x80, %al	/* Проверка на расширенный раздел Linux */
	cmpb	$0x05, %al	/* Проверка на расширенный раздел MS-DOS */
	jne	9f

/* Это расширенный раздел. Чтение расширенного раздела и попытка сканирования. */
8:
	movl	8(%bx), %eax		/* Смещение таблицы расширенных разделов */
	movl	20(%bp), %edx		/* "Корень" */
	addl	%edx, %eax		/* Вычисление нового адреса таблицы разделов */
	andl	%edx, %edx		/* Является ли это MBR? */
	jnz	10f
	movl	%eax, %edx		/* Смещение -> корень, если это был MBR */
10:
	call	read_partition_table	/* Чтение таблицы разделов */
	jc	11f		/* Переход, если ошибка чтения */
	call	scan_partition_table	/* Рекурсивный вызов для сканирования */
11:
	/* Возвращаемся к текущей таблице разделов */
	movl	28(%bp), %eax		/* "База" */
	call	read_partition_table

	/* Переход к следующему разделу */
9:
	addw	$16, %bx
	loopw	7b

	/* Ничего не найдено, возвращаемся */
	popal
	ret

/* Обработка слишком большого количества активных разделов */
too_many_active:
	call	error
	.ascii	"Multiple active partitions.\r\n"

/*
 * boot: запуск загрузчика. (%si) указывает на запись таблицы разделов,
 * и 28(%bp) содержит базовый адрес таблицы разделов.
 */
boot:
	movl	8(%si), %eax		/* Смещение начального сектора */
	addl	28(%bp), %eax		/* Коррекция адреса таблицы разделов */
	movl	%eax, 8(%si)		/* Коррекция записи в памяти */
	call	read_sector		/* Чтение сектора загрузчика */
	jc	disk_error		/* Переход при ошибке чтения сектора */

	/* Проверка, является ли прочитанный сектор суперблоком XFS */
	cmpl	$0x42534658, (bootsec) /* Проверка сигнатуры XFS */
	jne	no_xfs

	/* Корректировка адреса для загрузчика Syslinux */
	addl	$0x800 >> 0x09, %eax /* Плюс 4 сектора */
	call	read_sector		/* Чтение сектора Syslinux */
	jc	disk_error		/* Переход при ошибке чтения сектора */

no_xfs:
	cmpw	$0xaa55, (bootsec+510) /* Проверка сигнатуры загрузочного сектора */
	jne	missing_os		/* Если сигнатура не совпадает, ошибка */
	movw	$driveno, %sp		/* Установка указателя стека */
	popw	%dx		/* Восстановление номера диска */
	popw	%di		/* Восстановление указателя на PnP заголовок */
	popw	%es		/* Восстановление сегмента данных */
	cli			/* Отключение прерываний */
	jmpw	*%sp		/* Переход к загрузчику операционной системы */

disk_error:
	call	error
	.ascii	"Operating system load error.\r\n"

/*
 * Вывод сообщений об ошибках. Вызывается с "call", сообщение об ошибке
 * находится по адресу возврата.
 */
error:
	popw	%si
2:
	lodsb
	movb	$0x0e, %ah	/* Функция для вывода символа на экран */
	movb	(BIOS_page), %bh	/* Цвет символа */
	movb	$0x07, %bl	/* Атрибут символа */
	int	$0x10		/* Вызов прерывания BIOS */
	cmpb	$10, %al	/* Проверка на новую строку */
	jne	2b

	int	$0x18		/* Ошибка загрузки */
die:
	hlt		/* Остановка системы */
	jmp	die	/* Бесконечный цикл */


/*

Вот несколько ключевых аспектов, которые могут помочь в понимании:

1. Инициализация стека и сегментов: Загрузчик начинает с установки базовых сегментов и указателя стека. Это важно для корректного выполнения дальнейшего кода.

2. Копирование загрузочного сектора: Весь код загружается в память. Этот процесс обеспечивает, что код загрузчика будет находиться в правильном месте.

3. Проверка и настройка EBIOS: EBIOS используется для улучшенного взаимодействия с дисками. Код проверяет наличие EBIOS и, если он присутствует, делает соответствующие изменения для использования его возможностей.

4. Получение геометрии диска: Загрузчик получает информацию о диске, такую как количество секторов, головок и цилиндров. Это необходимо для корректного доступа к разделам и секторам диска.

5. Чтение и обработка таблицы разделов: Таблица разделов на диске содержит информацию о разделах и их типах. Код читает и анализирует эту таблицу, чтобы найти активные разделы и загрузить нужную операционную систему.

6. Загрузка операционной системы: Если найден подходящий раздел, загрузчик считывает и загружает сектор, содержащий операционную систему, и передает управление ей.

7. Обработка ошибок: Если что-то идет не так, загрузчик выводит сообщения об ошибках и останавливает выполнение.

*/