#include "adjust.h"

	.code16
	.text

	.globl	bootsec
stack		= 0x7c00
driveno		= (stack-6)
sectors		= (stack-8)
secpercyl	= (stack-12)

BIOS_kbdflags	= 0x417
BIOS_page	= 0x462

/* Секция данных для загрузочного сектора */
	.section ".bootsec", "a", @nobits
	.globl	bootsec
bootsec:
	.space	512  /* Резервируем 512 байт для загрузочного сектора */

	.text
	.globl	_start
_start:
	cli			/* Отключение прерываний */
	movw	%ax, %ds	/* Установка сегмента данных в 0 */
	movw	%ax, %ss	/* Установка сегмента стека в 0 */
	movw	$stack, %sp	/* Установка указателя стека */
	movw	%sp, %si	/* Установка %si в значение указателя стека */
	pushw	%es		/* Сохранение сегмента данных */
	movw	%ax, %es	/* Установка сегмента данных */
	sti			/* Включение прерываний */
	cld			/* Сброс флага направления */

/* Копирование загрузочного сектора в 0:0x600 */
	movw	$_start, %di	/* Установка указателя источника на начало кода */
	movw	$(512/2), %cx	/* Количество слов для копирования */
	rep ; movsw		/* Копирование данных из источника в целевой сегмент */

/* Переход к следующему этапу */
	ljmpw	$0, $next
next:

	ADJUST_DRIVE
	pushw	%dx		/* Сохранение номера диска */

/* Проверка наличия EBIOS */
	pushw	%dx		/* Номер диска */
	movb	$0x41, %ah	/* Функция для проверки наличия EBIOS */
	movw	$0x55aa, %bx	/* Сигнатура для проверки */
	xorw	%cx, %cx	/* Обнуление регистра %cx */
	stc			/* Установка флага переноса */
	int	$0x13		/* Вызов прерывания BIOS */
	jc	1f		/* Переход на метку 1, если ошибка */
	cmpw	$0xaa55, %bx	/* Сравнение сигнатуры */
	jne	1f		/* Переход на метку 1, если сигнатуры не совпадают */
	shrw	%cx		/* Обработка битов для фиксированных дисков */
	jnc	1f		/* Переход на метку 1, если нет EBIOS */

/* Патчирование кода для работы с EBIOS */
	movl	$0xeb42b4+((read_common-read_sector_cbios-4) << 24), \
		(read_sector_cbios)

1:
	popw	%dx		/* Восстановление номера диска */

/* Получение геометрии диска (C/H/S) */
	movb	$0x08, %ah	/* Функция для получения геометрии диска */
	int	$0x13		/* Вызов прерывания BIOS */
	andw	$0x3f, %cx	/* Количество секторов */
	pushw	%cx		/* Сохранение количества секторов в стеке */
	movzbw	%dh, %ax	/* Получение количества головок */
	incw	%ax		/* Коррекция значения для подсчета */
	mulw	%cx		/* Умножение головок на количество секторов */

/* Сохранение количества секторов на цилиндр в стеке */
	pushw	%dx		/* Высший разряд */
	pushw	%ax		/* Низший разряд */

/* Вызов функции для сканирования таблицы разделов */
	xorl	%eax, %eax	/* Обнуление регистра %eax */
	cdq			/* Расширение знака регистра %eax в %edx */
	call	scan_partition_table	/* Вызов функции сканирования таблицы разделов */

/* Если мы здесь, то нет операционной системы */
missing_os:
	call	error
	.ascii	"Missing operating system.\r\n"

/* Вызов кастомной функции */
	extern my_custom_function	/* Объявляем функцию на языке C */
	call	my_custom_function	/* custom: вызов функции на языке C */

/*
 * read_sector: Чтение одного сектора, указанный в %eax, в 0x7c00.
 * CF установлен при ошибке. Все регистры сохранены.
 */
read_sector:
	pushal
	xorl	%edx, %edx	/* Обнуление регистра %edx */
	movw	$bootsec, %bx	/* Установка адреса буфера для сектора */
	pushl	%edx		/* Высший разряд LBA */
	pushl	%eax		/* Низший разряд LBA */
	pushw	%es		/* Сегмент буфера */
	pushw	%bx		/* Смещение буфера */
	pushw	$1		/* Количество секторов */
	pushw	$16		/* Размер пакета */
	movw	%sp, %si	/* Установка указателя стека */

/* Этот фрагмент пропускается, если у нас есть EBIOS */
read_sector_cbios:
	divl	(secpercyl)	/* Деление для получения цилиндра */
	shlb	$6, %ah	/* Коррекция значения %ah */
	movb	%ah, %cl	/* Установка значения цилиндра */
	movb	%al, %ch	/* Установка значения сектора */
	xchgw	%dx, %ax	/* Обмен значениями регистров */
	divb	(sectors)	/* Деление для получения головки */
	movb	%al, %dh	/* Установка значения головки */
	orb	%ah, %cl	/* Объединение значений */
	incw	%cx		/* Коррекция для 1-based значения */
	movw	$0x0201, %ax	/* Установка функции чтения сектора */

/* Чтение сектора с использованием общего кода */
read_common:
	movb	(driveno), %dl	/* Установка номера диска */
	int	$0x13		/* Вызов прерывания BIOS для чтения сектора */
	leaw	16(%si), %sp	/* Восстановление указателя стека */
	popal
	ret

/*
 * read_partition_table:
 * Чтение таблицы разделов (по адресу в %eax) и копирование
 * таблицы разделов в буфер ptab.
 *
 * Искажает %si, %di и %cx, остальные регистры сохранены.
 * %cx = 0 по завершению.
 *
 * При ошибке CF установлен, ptab перезаписан мусором.
 */
ptab	= _start+446

read_partition_table:
	call	read_sector	/* Чтение сектора таблицы разделов */
	movw	$bootsec+446, %si	/* Источник */
	movw	$ptab, %di		/* Приемник */
	movw	$(16*4/2), %cx	/* Количество слов */
	rep ; movsw		/* Копирование данных */
	ret

/*
 * scan_partition_table:
 * Сканирование таблицы разделов, загруженной в область таблицы разделов.
 * Сохранение всех регистров.
 *
 * При входе:
 * %eax - базовый адрес (местоположение этой таблицы разделов)
 * %edx - корень (смещение от MBR, или 0 для MBR)
 *
 * Эти значения сохраняются в стековых ячейках:
 * 28(%bp) - %eax - база
 * 20(%bp) - %edx - корень
 */

scan_partition_table:
	pushal
	movw	%sp, %bp	/* Сохранение указателя стека */

/* Поиск активных разделов */
	movw	$ptab, %bx	/* Установка указателя на таблицу разделов */
	movw	$4, %cx	/* Количество разделов */
	xorw	%ax, %ax	/* Обнуление счетчика активных разделов */
	push	%bx
	push	%cx
5:
	testb	$0x80, (%bx)	/* Проверка флага активности */
	jz	6f
	incw	%ax		/* Увеличение счетчика активных разделов */
	movw	%bx, %si
6:
	addw	$16, %bx	/* Переход к следующему разделу */
	loop	5b

	movw	%ax, %cx	/* Количество активных разделов */

/* Сброс стека */
	movw	%bp, %sp	/* Восстановление указателя стека */
	popal
	ret


/*

*** my_custom_function.c

void my_custom_function() {
    // Пример функции на языке C
    // Вы можете поместить сюда вашу кастомную логику
    // Например, просто зависнуть или выводить сообщение
}



*** Makefile для компиляции и связывания файлов:

# Задачи
all: mbr.bin

# Правило для создания загрузочного сектора
mbr.bin: mbr.o my_custom_function.o
	ld -o mbr.bin -Ttext 0x7c00 -o mbr.bin mbr.o my_custom_function.o --oformat binary

# Правило для компиляции ассемблерного файла
mbr.o: mbr.S
	nasm -f elf32 -o mbr.o mbr.S

# Правило для компиляции C-файла
my_custom_function.o: my_custom_function.c
	gcc -ffreestanding -c -o my_custom_function.o my_custom_function.c

# Очистка сгенерированных файлов
clean:
	rm -f *.o mbr.bin


*/